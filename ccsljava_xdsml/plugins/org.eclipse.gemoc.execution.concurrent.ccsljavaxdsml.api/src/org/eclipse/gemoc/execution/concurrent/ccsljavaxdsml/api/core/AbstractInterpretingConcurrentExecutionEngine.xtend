package org.eclipse.gemoc.execution.concurrent.ccsljavaxdsml.api.core

import java.util.HashSet
import java.util.Set
import org.eclipse.gemoc.trace.commons.model.generictrace.GenericParallelStep
import org.eclipse.gemoc.trace.commons.model.generictrace.GenericSmallStep
import org.eclipse.gemoc.trace.commons.model.generictrace.GenerictraceFactory
import org.eclipse.gemoc.trace.commons.model.trace.ParallelStep
import org.eclipse.gemoc.trace.commons.model.trace.SmallStep
import org.eclipse.gemoc.trace.commons.model.trace.Step

abstract class AbstractInterpretingConcurrentExecutionEngine<C extends AbstractConcurrentModelExecutionContext<R, ?, ?>, R extends IConcurrentRunConfiguration> extends AbstractConcurrentExecutionEngine<C, R> {

	/**
	 * Compute the atomic steps currently available.
	 */
	def abstract Set<? extends GenericSmallStep> computePossibleSmallSteps()

	/**
	 * Create a clone of the given small step, assuming that this step has previously been created by this engine.
	 */
	def abstract GenericSmallStep createClonedSmallStep(GenericSmallStep gss)

	/**
	 * Compare the two steps (previously generated by this engine) and return true if they could run concurrently.
	 * 
	 * Assumed to be computing a reflexive and symmetric relation.
	 */
	// TODO: Change parameter types to GenericSmallStep for clarity
	// TODO: Cache results as this will likely be invoked multiple times for the same combination of steps 
	def abstract boolean canInitiallyRunConcurrently(Step<?> s1, Step<?> s2)

	extension static val GenerictraceFactory traceFactory = GenerictraceFactory.eINSTANCE

	override protected computeInitialLogicalSteps() {

		var Set<ParallelStep<?, ?>> possibleLogicalSteps = new HashSet<ParallelStep<?, ?>>()

		val atomicSteps = computePossibleSmallSteps

		possibleLogicalSteps += atomicSteps.generateConcurrentSteps.map [ seq |
			if (seq.subSteps.length > 1) {
				seq
			}
		].filterNull

		possibleLogicalSteps += atomicSteps.map [ m |
			// Concurrent engine expects everything to be a parallel step
			val GenericParallelStep pstep = createGenericParallelStep
			pstep.subSteps += m

			pstep
		].toSet

		possibleLogicalSteps
	}

	/**
	 * Generate all possible maximally concurrent steps
	 * 
	 * @param matchList all current atomic matches
	 */
	private def Set<GenericParallelStep> generateConcurrentSteps(Set<? extends GenericSmallStep> matchList) {
		var possibleSequences = new HashSet<GenericParallelStep>

		createAllStepSequences(matchList, possibleSequences, new HashSet<GenericSmallStep>)

		possibleSequences
	}

	/**
	 * Recursively explore all matches, check if they have conflicts and create max valid rule sequence
	 * 
	 * @param a list of all matches, a list of lists of all possible sequences, current stack
	 */
	private def void createAllStepSequences(Set<? extends GenericSmallStep> allSmallSteps,
		Set<GenericParallelStep> possibleSequences, Set<GenericSmallStep> currentStack) {
		var foundOne = false
		// TODO Change to only explore the upper hyper-triangle
		for (GenericSmallStep m : allSmallSteps) {
			if (!currentStack.contains(m)) {
				if (!hasConflicts(m, currentStack)) {
					foundOne = true
					var clonedStack = new HashSet<GenericSmallStep>(currentStack)
					clonedStack += m
					createAllStepSequences(allSmallSteps, possibleSequences, clonedStack)
				}
			}
		}

		if (!foundOne) {
			val pstep = createGenericParallelStep
			pstep.subSteps += currentStack.map[createClonedSmallStep]

			possibleSequences += pstep
		}
	}

	/**
	 * Check if a match has conflicts with a set of other matches
	 * 
	 * @param match and a list of matches
	 */
	private def hasConflicts(SmallStep<?> match, Set<GenericSmallStep> matches) {
		matches.exists[m|match.cannotRunConcurrently(m)]
	}

	/**
	 * Check if two matches cannot be executed in parallel. First checks if the two matches 
	 * conflict based on the CPA analysis. Then checks if all concurrency strategies agree 
	 * that they should be run in parallel.
	 * 
	 * @param match1 and match2
	 * 
	 * @output true if the two matches should not run in parallel
	 */
	private def cannotRunConcurrently(SmallStep<?> match1, SmallStep<?> match2) {
		!canInitiallyRunConcurrently(match1, match2) || !applyConcurrencyStrategies(match1, match2)

	}

}
